### 一、Html部分:

#### 1.为什么不能定义1px左右的div容器

```html
IE6下这个问题是因为默认的行高造成的，解决的方法也有很多，例如：
overflow:hidden | zoom:0.08 | line-height:1px
```

#### 2.简述readyonly与disabled的区别

```html
ReadOnly和Disabled的作用是使用户不能够更改表单域中的内容.
但是二者还是有着一些区别的：
1、Readonly只针对input(text/password)和textarea有效，而disabled对于所有的表单元素有效，包括select,radio,checkbox,button等。
2、在表单元素使用了disabled后，我们将表单以POST或者GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去
```

#### 3.**XHTML 与 HTML 有什么区别？**

```html
1. 所有的标记都必须要有一个相应的结束标记
2. 所有标签的元素和属性的名字都必须使用小写
3. 所有的 XML 标记都必须合理嵌套
4. 所有的属性必须用引号 "" 括起来
5. 把所有 < 和 & 特殊符号用编码表示
6. 给所有属性赋一个值
7. 不要在注释内容中使用 "--"
8. 图片必须有说明文字
```

#### 4.**对Web标准以及W3C的理解和认识**

```html
1.标签闭合,标签小写,不乱嵌套,提高搜索机器人搜索几率,使用外链CSS和js脚本,结构行为表现的分离.
2.文件下载与页面速度更快,内容能被更多的用户所访问, 内容能被广泛的设备所访问,更少的代码和组件
3.容易维护, 改版方便, 不需要变动页面内容, 提供打印版本而不需要复制内容, 提高网站易用性.
```

#### 5.**iframe的作用**

```html
iframe是用来在网页中插入第三方网页,早起的页面使用iframe主要是用于到导航栏这种很多页面都相同的部分, 这样可以在切换页面的时候避免重复加载.现在很少使用了.
```

#### 6. 如何检测页面加载和渲染性能,具体指标有哪些?

##### **基于网页分析工具：**

```js
1.17CE
2.百度移动APP测试服务
3.PingDom Tools
4.https://gtmetrix.com/
```

**基于浏览器分析工具：**

```js
1.Chrome自带工具F12
2.Firefox插件：YSlow（Yahoo工具）
3.Page Speed（google）
```

**具体指标有:**

```js
1.页面加载时间: 从页面开始加载到页面onload事件触发的时间.
2.全部页面加载事件: 最初启动浏览开始, 直到所有元素都被加载完成后, 在2秒后任然没有网络活动的时间.
3.从开始加载到收到服务器返回数据的第一个字节的时间
4.DNS事件: 进行域名解析所需要的时间
5.HTPP网页打分: 页面渲染, 下载速度, 页面流畅度
6.TCP时间: 客户端建立连接的时间
```

####7.列举不少于6条的IE与FF脚本兼容性问题，需要写出命令

```html
(1) window.event： 

表示当前的事件对象，IE有这个对象，FF没有，FF通过给事件处理函数传递事件对象 

(2) 获取事件源 

IE用srcElement获取事件源，而FF用target获取事件源 

(3) 添加，去除事件 

IE：element.attachEvent(“onclick”, function) element.detachEvent(“onclick”, function) 

FF：element.addEventListener(“click”, function, true) element.removeEventListener(“click”, function, true) 

(4) 获取标签的自定义属性 

IE：div1.value或div1[“value”] 

FF：可用div1.getAttribute(“value”) 

(5) document.getElementByName()和document.all[name] 

IE；document.getElementByName()和document.all[name]均不能获取div元素 

FF：可以 

(6) input.type的属性 

IE：input.type只读 

FF：input.type可读写 

(7) innerText textContent outerHTML 

IE：支持innerText, outerHTML 

FF：支持textContent 

(8) 是否可用id代替HTML元素 

IE：可以用id来代替HTML元素 

FF：不可以 
```

#### 8.本地存储（Local Storage ）和cookies（储存在用户本地终端上的数据）之间的区别是什么？

```html
Cookies:服务器和客户端都可以访问；大小只有4KB左右；有有效期，过期后将会删除；

本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST或者GET的通道发送到服务器；每个域5MB；没有过期数据，它将保留知道用户从浏览器清除或者使用Javascript代码移除
```

####9.如何对网站的文件和资源进行优化？

```html
文件合并
文件最小化/文件压缩
使用CDN托管
缓存的使用
```

#### 10.HTML5 Canvas 元素有什么用？

```html
Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作。
```

#### 11.[用H5+CSS3]()解决下导航栏最后一项掉下来的问题

```html
box-sizing: border-box;
```

####  12. 为什么利用多个域名来存储网站资源会更有效？

```html
CDN缓存更方便 
突破浏览器并发限制 
节约cookie带宽 
节约主域名的连接数，优化页面响应速度 
防止不必要的安全问题
```

#### 13.简述一下你对web性能优化的方案？

```html
1、尽量减少 HTTP 请求
2、使用浏览器缓存
3、使用压缩组件
4、图片、JS的预载入
5、将脚本放在底部
6、将样式文件放在页面顶部
7、使用外部的JS和CSS
8、精简代码
```

#### 14.谈谈浏览器的内核，并且说一下什么是内核？

```html
Trident (['traɪd(ə)nt])--IE，Gecko (['gekəʊ])--Firefox, Presto (['prestəʊ])--opera,webkit—谷歌和Safari
浏览器内核又可以分成两部分：渲染引擎和 JS 引擎。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。
```

#### 15.html常见兼容性问题？

```html
1.双边距BUG float引起的  使用display
2.3像素问题 使用float引起的 使用dislpay:inline -3px  
3.超链接hover 点击后失效  使用正确的书写顺序 link visited hover active
4.Ie z-index问题 给父级添加position:relative
5.Png 透明 使用js代码 改
6.Min-height 最小高度 ！Important 解决’
7.select 在ie6下遮盖 使用iframe嵌套
8.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px）
9.IE5-8不支持opacity，解决办法：
.opacity {
    opacity: 0.4
    filter: alpha(opacity=60); /* for IE5-7 */
    -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=60)"; /* for IE 8*/
}
10. IE6不支持PNG透明背景，解决办法: IE6下使用gif图片
```

#### 16. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？

```html
（1）CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，比如div默认display属性值为“block”，成为“块级”元素；span默认display属性值为“inline”，是“行内”元素。  
（2）行内元素有：a b span img input select strong（强调的语气） 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p  
（3）知名的空元素：      
<br><hr><img><input><link><meta>鲜为人知的是： <area><base><col><command>
<embed><keygen><param><source><track><wbr>
```



### 二、css部分：

#### 1.**介绍一下你对浏览器内核的理解?常见的浏览器内核有哪些?以及处理css样式的前缀？**

```css
浏览器内核由两个部分组成,第一部分是渲染引擎, 第二部分是Javascript解析器.
现在主流的内核有4中

Tridnet: IE浏览器, 腾讯浏览器, 遨游浏览器, 360浏览器
Gecko: Firefox浏览器
Webkit: Safari浏览器
Blinke: Chorme浏览器, Opera浏览器

-ms-transform:rotate(7deg);      //  -ms-代表IE浏览器识别前缀
-moz-transform:rotate(7deg);      //  -moz-代表火狐浏览器识别前缀
-webkit-transform:rotate(7deg);    //  -webkit-代表谷歌和Safari浏览器识别前缀
-o-transform:rotate(7deg);          //  -o- 代表Opera浏览器识别前缀

transform;rotate(7deg)           // 统一标识语句，符合w3c标准
```

#### 2.**水平垂直居中的方式有几种?**

```css
1.将margin-left和margin-right设置为auto    margin:0 auto
	<style>
            .child{
                margin: 0 auto;
                width:50px; 
            }
    </style>
2.采用absolute + transform的方式(绝对定位+水平移动)
        <style>
                .parent{
                    position : relative;
                }
                .child{
                    position: absolute;
                    left:50%;
                    top:50%;
                    transform: translate(-50%,-50%);
                }
        </style>
3.采用inline-block + text-align + table-cell + vertical-align(单元格方式)
		<style>
            .parent{
                display:table-cell;
                vertical-align:middle;
                text-align:center;
                width:200px;  /*如果使用该方法,父盒子得设定宽度*/
            }
            .child{
                display:inline-block;
            }
        </style>
```

#### 3.**描述一下CSS中的渐进增强, 优雅降级之间的区别?**

```css
优雅降级指的是为现代浏览器制作网站,然后保证为某些老版本的流浪器提供基于可用的体验. 新特性在老版本浏览器中会降级, 且一般会有一个分界点, 声明不支持哪些老掉牙的浏览器. 有些时候也会警告用户更换其浏览器.

渐进增强与优雅降级相反. 渐进增强一开始就针对低版本浏览器构建页面,然后再针对高级浏览器增加特效和其他交互效果.渐进增强关注内容本身.
```

#### 4.(待)清除浮动的几种方法，及各自的优缺点？

#### 5.**IE盒模型和W3C盒模型有什么不同？**

```css
IE盒模型：margin 、 content（包含border、padding）
W3C盒模型： margin 、border、 padding、 content

CSS3中的box-sizing的属性就是为了这两种模式，border-box（IE盒明星）和content-box（W3C）
```

#### 5.简述一下Sass、Less，且说明区别？

```css
他们是动态的样式语言，是CSS预处理器,CSS上的一种抽象层。他们是一种特殊的语法/语言而编译成CSS。
变量符不一样，less是@，而Sass是$;
Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持;
Sass是基于Ruby的，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出Css到浏览器
```

#### 6.超链接访问过后hover样式就不出现的问题是什么？如何解决？

```css
被点击访问过的超链接样式不在具有hover和active了,解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active）
```

#### 7.rgba()和opacity的透明效果有什么不同？

```css
rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，
而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！）
```

#### 8. css中可以让文字在垂直和水平方向上重叠的两个属性是什么？

```css
垂直方向：line-height
水平方向：letter-spacing
那么问题来了，关于letter-spacing的妙用知道有哪些么？
答案:可以用于消除inline-block元素间的换行符空格间隙问题。
```

#### 9.CSS中可以通过哪些属性定义，使得一个DOM元素不显示在浏览器可视范围内？

```css
最基本的：
设置display属性为none，或者设置visibility属性为hidden
技巧性：
设置宽高为0，设置透明度为0，设置z-index位置在-1000em
```

####10.display:none与visibility:hidden的区别是什么？

```css
display : 隐藏对应的元素但不挤占该元素原来的空间。
visibility: 隐藏对应的元素并且挤占该元素原来的空间。
即是，使用CSS display:none属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用visibility:hidden属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。
```

#### 11.CSS中link和@import的区别是：

```css
在css中@import 导入指定的的外部样式表及目标媒体，css导入外部文件主要是通过link和@import实现的，它们都各自的语法结构。
  
@import代码示例如下：

<style type="text/css">@import url(路径地址/test.css);</style>

link的代码示例如下：

<link href="路径地址/test.css" rel="stylesheet" type="text/css" />

css中@import和link的区别:
  1、属性不同
  link是html提供的标签，不仅可以加载css文件，还能定义 RSS、rel 连接属性等。而
   @import是css中的语法规则。
  
  2、加载顺序不同
  页面打开时，link引用的css文件被加载。而@import引用的CSS等页面加载完后最后加载。
  
  3、兼容性
  @import是css2.1后提出的，而link是不存在兼容问题。
  
  4、DOM控制性
  js操作DOM，可以使用link改变样式，无法使用@import的方式使用样式。
```

#### 12. 哪些css属性可以继承？

```css
有继承性的属性：
1、字体系列属性        
font：组合字体        font-family：规定元素的字体系列        font-weight：设置字体的粗细        font-size：设置字体的尺寸        font-style：定义字体的风格        font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为        大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。        font-stretch：允许你使文字变宽或变窄。所有主流浏览器都不支持。        font-size-adjust：为某个元素规定一个 aspect 值，字体的小写字母 "x" 的高度与        "font-size" 高度之间的比率被称为一个字体的 aspect 值。这        样就可以保持首选字体的 x-height。

2、文本系列属性
text-indent：文本缩进  text-align：文本水平对齐   line-height：行高   word-spacing：增加或减少单词间的空白（即字间隔）   letter-spacing：增加或减少字符间的空白（字符间距）  text-transform：控制文本大小写   direction：规定文本的书写方向   color：文本颜色

3.元素可见性：visibility

4、表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout

5、列表属性：list-style-type、list-style-image、list-style-position、list-style

6、生成内容属性：quotes

7、光标属性：cursor

8、页面样式属性：page、page-break-inside、windows、orphans

9、声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、        speech-rate、volume、voice-family、pitch、pitch-range、        stress、richness、、azimuth、elevation

所有元素可以继承的属性：
1、元素可见性：visibility、opacity        2、光标属性：cursor

内联元素可以继承的属性:
1、字体系列属性        2、除text-indent、text-align之外的文本系列属性

块级元素可以继承的属性:
1、text-indent、text-align

无继承的属性:
1、display        
2、文本属性：vertical-align：        text-decoration：        text-shadow：        white-space：        unicode-bidi：        
3、盒子模型的属性:宽度、高度、内外边距、边框等        
4、背景属性：背景图片、颜色、位置等        
5、定位属性：浮动、清除浮动、定位position等        
6、生成内容属性:content、counter-reset、counter-increment        
7、轮廓样式属性:outline-style、outline-width、outline-color、outline        
8、页面样式属性:size、page-break-before、page-break-after继承中比较特殊的几点1、a 标签的字体颜色不能被继承1、h1-h6标签字体的大下也是不能被继承的因为它们都有一个默认值
```







### 三、Js基础部分：

#### 1.Js解决兼容性的方法？

#### 2.封装函数解析（url解析）

var url = 'http://www.itheima.com/login.html?name=zs&age=18';

得到{
   name: 'zs',
   age: 18
}

```js
<script>
        var url = 'http://www.itheima.com/login.html?name=zs&age=18';

        function getParams(url) {
            var params = {};
            var urls = url.split("?");
            var arr = urls[1].split("&");
            // console.log(arr);
            for (var i = 0; i < arr.length; i++) {
                var arr1 = arr[i].split("=");
                // console.log(arr1);
                params[arr1[0]] = arr1[1];
            }
            // return params;
            console.log(params);
        }
        getParams(url);

    </script>
```



#### 3.es5的迭代方法以及各自的作用?

```js
forEach(),map(),filter(),some(),every()
```



#### 4.window.location的一些常用命令

```js
4.1 window.location.search():会返回当前页面查询字符部分, 也就是url中以?开始的部分.
4.2 window.location.hash:会返回当前页面查询字符部分, 也就是url中以?开始的部分.
4.3 window.location.reload()：刷新当前页面
```



#### 5.**请简述javascript 中的垃圾回收机制**

```js
js在创建对象, 调用函数等操作的时候都会涉及到申请内存, 函数的内存由系统进行管理, 一旦调用结束后内存回收. 但是对象的内存由js引擎进行管理,js中对象具有动态特性,所以js引擎会带有垃圾回收机制.

垃圾回收机制具有释放不使用的内存和整合内存的作用. 然而因为会进行内存的整合, 所以在进行垃圾回收的时候会影响浏览器的性能.浏览器会使用一些算法来确定垃圾回收的时机, Chrome浏览器中采用的是分代回收的方法.
```



#### 6.BOM对象有哪些，列举window对象？

```js
window对象 ，是JS的最顶层对象，其他的BOM对象都是window对象的属性；
document对象，文档对象；
location对象，浏览器当前URL信息；
navigator对象，浏览器本身信息；
screen对象，客户端屏幕信息；
history对象，浏览器访问历史信息；
```

#### 7.bind(), live(), delegate()的区别

```js
bind： 绑定事件，对新添加的事件不起作用，方法用于将一个处理程序附加到每个匹配元素的事件上并返回jQuery对象。
live： 方法将一个事件处理程序附加到与当前选择器匹配的所有元素（包含现有的或将来添加的）的指定事件上并返回jQuery对象。
delegate： 方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素（现有的或将来的）的一个或多个事件上。  
```

#### 8. **普通事件和事件绑定有什么区别?**

```js
1.普通事件:
（1）给html元素添加特定的属性
（2）采用<div onclick="doSomeThing()">点我</div>
（3）采用document.querySelector('div').onclick = function(){}
（4）普通事件只能为同一个元素添加单个事件, 后面的事件会覆盖掉前面的事件

2.事件绑定:
（1）使用addEventListener()添加事件
（2）采用事件绑定可以为其添加多个事件, 其事件的执行顺序是从最先添加的事件开始依次执行
```

#### 9.**addEventListener()和attachEvent()的区别**

```js
（1）addEventListener()是符合W3C规范的标准方法;  attachEvent()是IE低版本的非标准方法
（2）addEventListener()支持事件冒泡和事件捕获; 而attachEvent()只支持事件冒泡
（3）addEventListener()的第一个参数中,事件类型不需要添加on; attachEvent()需要添加'on'
（4）如果为同一个元素绑定多个事件, addEventListener()会按照事件绑定的顺序依次执行, attachEvent()会按照事件绑定的顺序倒序执行.
```

#### 10.**闭包是什么? 有什么特性? 对页面有什么影响?**

```js
1.闭包是什么:闭包是指有权访问另一个函数作用域中变量的函数.
2.闭包有什么特性:
    通过闭包,可以提供私有作用域.
    函数执行完后,内部不会释放
    通过闭包,可以实现带有存储函数运行时变量的函数.
3.对页面有什么影响:
	大量使用闭包会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
```

#### 11.**如何阻止事件冒泡和html标签的默认行为?**

```js
(1) 阻止事件冒泡:
	IE8及以下: window.event.cancelBubble = true
	IE9及以上/Chorme/Firefox: event.stopPropagation()
(2) 阻止html标签的默认行为:
	IE8及以下: window.event.returnValue = false
	IE9及以上/Chorme/Firefox: event.preventDefault()
```

#### 12.（待）**编写一个数组去重的方法**

**方法1:采用数组的filter方法**

```js
function filterRepetition ( arr ) {
    return arr.filter(function ( item, index, array ){
        return array.indexOf( item ) === index;
    })
}
```

**方法2:采用缓存的方法**

```js
function filterRepetition ( arr ) {
    var cache = {};
    var resultArr = [];
    for( var i = 0; i < arr.length; i++ ){
        if( cache[arr[i]] ) {
            continue;
        }else{
            cache[arr[i]] = true;
            resultArr.push( arr[i] );
        }
    }
    return resultArr;
}
```

#### 13.**获取页面所有的checkbox**

```js
var resultArr= [];
var input = document.querySelectorAll('input');
for( var i = 0; i < input.length; i++ ) {
    if( input[i].type == 'checkbox' ) {
        resultArr.push( input[i] );
    }
}
//resultArr即中获取到了页面中的所有checkbox
```

#### 14.**以下代码的输出结果**

```js
console.log( null == undefined ); //true
console.log( null === undefined ); //false
console.log( [] == false ); //true
```

#### 15.**将字符串"<tr><td>{${$name}</td></tr>{$id}"中的{$id}替换成10，{$name}替换成"Tony" （使用正则表达式）**

```js
var str  = '<tr><td>{$id}</td><td>{$name}</td></tr>{$id}';
var newStr = str.replace( /{\$id}/g, 10 ).replace( /{\$name\}/g, 'Tony' );
```

#### 16.**为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将<, >, &, “进行转义**

```js
function escapeHtml ( str ) {
    var exp = /[<>&]/g;
    var newStr = str.replace( exp, function( match ) {
        //该传入什么参数 
        if( match === '<' ) {
            return '<'
        }else if ( match === '>' ) {
            return '&gt'
        }else if ( match ==='&' ) {
            return '&'
        }
    }) 
    return newStr;   
}
```

#### 17.**用js实现随机选取10–100之间的10个数字，存入一个数组，并排序**

```js
function getSortedRandomNumber () {
    var arr = [];
    for( var i = 0; i < 10; i++ ) {
        arr.push( Math.floor( Math.random() * 90 ) + 10 );
    }
    return arr.sort(function ( a, b ) {
        return a - b;
    })
}
```

#### 18.**有这样一个URL：`http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e`，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按`key-value`形式返回到一个json结构中，如`{"a":"1","b":"2","c":"","d":"xxx","e":"undefined"}`**

```js
function getQueryJson ( URLstr ) {
    var queryIndex = URLstr.indexOf('?') + 1;
    var queryStr = URLstr.slice( queryIndex ); //a=1&b=2&c=&d=xxx&e
    var arr = queryStr.split( '&' ); //[ a=1, b=2, c=, d=xxx, e ]
    var obj = {};
    var resultArr =  [];
    for( var i = 0; i < arr.length; i++ ) {
        var tempArr = arr[ i ].split( '=' );
        obj[ tempArr[0] ] = tempArr[1];
    }
    for( var key in obj ){
        resultArr.push( '"' + key + '"' + ':'  + '"' + obj[ key ] + '"'   ); 
    }
    return '{' + resultArr.join(',') + '}'; //{"a":"1","b":"2","c":"","d":"xxx","e":"undefined"}
}
```

- 注意: 如果这道题目最后没有那个`e`,即URL是`http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx`,那么代码可简化为:

  ```js
  function getQueryJson ( URLstr ) {
      var queryIndex = URLstr.indexOf('?') + 1;
      var queryStr = URLstr.slice( queryIndex ); //a=1&b=2&c=&d=xxx&e
      var arr = queryStr.split( '&' ); //[ a=1, b=2, c=, d=xxx, e ]
      var obj = {};
      var resultArr =  [];
      for( var i = 0; i < arr.length; i++ ) {
          var tempArr = arr[ i ].split( '=' );
          obj[ tempArr[0] ] = tempArr[1];
      }
      return JSON.stringify( obj ); //{"a":"1","b":"2","c":"","d":"xxx"}
  }
  ```

#### 19.**看下面代码，给出输出结果**

```js
for(var i=1;i<=3;i++){
  setTimeout(function(){
      console.log(i);    
  },0);  
}
结果: 4, 4, 4
```

**追问 : 如何让代码输出1,2,3? (两种方法)**

- 方法1: 采用立即执行函数

```js
for( var i = 1; i <= 3; i++ ) {
    setTimeout( function( num ) {
        return function () {
            console.log( num );
        }
    } ( i ), 0);
}
```

- 方法2: 采用闭包

```js
for( var i = 1; i <= 3; i++ ) {
    setTimeout( (function (){
        var j = i;
        return function () {
            console.log( j );
        }
    })(), 0);
}
```

#### 20.**写一个function，清除字符串前后的空格。（兼容所有浏览器）**

```js
if( typeof String.prototype.trim !== 'function' ) {
    String.prototype.trim = function( ) {
        return this.replace ( /^\s*|\s*$/g, '' );
    }
}
```

#### 21.**Javascript中callee和caller的作用**

```js
callee是arguments的一个属性,返回的是正在执行的函数的本身的引用
caller返回一个函数的引用，被返回的这个函数调用了当前的函数
```

#### 22.**实现检索当前页面中的表单元素中的所有文本框，并将它们全部清空的函数**

```js
function clearText() {
    var texts = document.getElementsByTagName( 'input' );
    for( var i = 0; i< texts.length; i++ ) {
        if( texts[ i ].type === 'text' ) {
            texts[ i ].value = '';
        }
    }
}
```

#### 23.**写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉**

```js
var reg = /(<\w+>)|(<\/\w+>)/gi;
var str = '<div>这里是div<p>里面的段落</p></div>';
alert(str.replace(reg,""));
```

#### 24.**截取字符串abcdefg的efg**

方法一: 使用String.prototype.slice()方法

```js
var str = "abcdefg";
var newStr = str.slice( 4 );
console.log( newStr );  //efg
```

方法二: 使用String.prototype.substring()方法

```js
var str = "abcdefg";
var newStr = str.substring( 4 );
console.log( newStr ); //efg 
```

#### 25.**列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个**

```js
BOM中常用的对象: window, history, document, location, navigator

BOM对象的常用方法: alert(), confirm(), open(), close(), setTimeout(), setInterval(), clearInterval(), clearTimeout
```

#### 26.(待)**Javascript创建对象的几种方式？**

#### 27.**请你谈谈Cookie的优缺点？**

```js
优点：　
1. 通过良好的编程，可控制保存cookie中的session对象的大小
2. 通过加密和安全传输技术(SSL),可减少cookie被破解的可能性
3. 可在cookie中存放不敏感数据.
4. cookie的生命周期可控, 通过控制cookie的声明周期,让其不会永远有效

缺点:
1. cookie的数量和长度有限.每个特定的域名下最多生成20个cookie,每个cookie长度不能超过4kb
2. 额外开销,cookie在每次发起Http请求的时候都会被发送给服务器,会增加开销
3. 安全性问题,cookie不去拿全, 拦截之后会暴露session信息
```

#### 28.**js延迟加载的方式有哪些？**

```js
(1)直接将script节点放置在</body>之前, 这样js脚本就会在页面显示出来之后再加载
(2)使用script标签的defer属性, defer属性为延迟加载, 是在页面渲染完成之后再进行加载.但是有些浏览器不支持
```

```js
(3)通过监听onload事件,动态加载script节点,google推荐的代码如下:
```

```js
function downloadJSAtOnload(){
    var element = document.createElement('script');
    element.src = "defer.js";  //此处的js文件是你引入的文件路径
    document.body.appendChild(element);
}
if(window.addEventListener){
    window.addEventListener('load',downloadJSAtOnload,false);
}else if (window.attchEvent) {
    window.attchEvent('onload', downloadJSAtOnload);
}else{
    window.onload = downloadJSAtOnload;
}
```

```js
(4)通过ajax下载脚本,动态添加script节点
```

```js
var xhr = new XMLHttpRequest();
xhr.open("get","script.js",true);
xhr.onreadystatechange = function() {
    if(xhr.readyState == 4) {
        if(xhr.status >= 200 && xhr.status<300 || xhr.status==304) {
            var script = document.createElement('script');
            script.type = "text/javascript";
            script.text = xhr.responseText;
            document.body.appendChild(script);
        }
    }
}
```

#### 29.**哪些操作会造成内存泄漏？**

**内存泄漏是指向系统申请了内存后不能释放, 使得这片内存不能再被重新申请. 以下的操作会造成内存泄漏:**

```js
(1)当页面中元素被移除或替换时,若元素绑定的事件没有被移除, 在IE中不会做出处理,此时要先手工移除事件, 不然会造成内存泄漏.
(2)在IE中,如果循环引用的对象是DOM节点,会造成内存泄漏.
(3)闭包时构成的循环引用会造成内存泄漏.
(4)在IE中, 自动类型转箱转换会造成内存泄漏.
内存泄漏实例见: http://www.jb51.net/article/37685.htm

内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。
setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）
```

#### 30.**编写一个函数,用于统计一个字符串中出现次数最多的字符和其出现的次数？**

```js
var str = 'asdfssaaasasasasaa';
function findMaxAppearChar () {
    var arr = str.split('');
    var obj = {};
    var maxKey = ''; 
    var maxIndex = 0;
    for( var i = 0; i < arr.length; i++ ) {
        if( obj[ arr[i] ] ){
            obj[ arr[i] ] += 1;
        }else{
            obj[ arr[i] ] = 1;
        }
    }
    for( key in obj ) {
        if(obj[key] > maxIndex) {
            maxKey = key;
            maxIndex = obj[key];
        }
    }
    return ('出现最多字符是' + maxKey + ',一共出现了' + maxIndex + "次");
}
```

#### 31.**写一个获取非行内样式的函数,要求兼容IE低版本浏览器**

```js
function getStyle ( obj, attr ) {
    if( obj.currentStyle ) {
        return obj.currentStyle[ attr ]; //兼容IE低版本
    }else{
        return window.getComputedStyle( obj, null )[ attr ];
    }
}
```

#### 32.**解释jsonp的原理，以及为什么不是真正的Ajax**

```json
jsonp的原理是通过<script>标签向服务器发送请求，将前端函数名称作为参数传递到服务器，服务器接收到请求后将 JSON 数据作为该方法的参数，返回 JavaScript 文本，前端方法就可以拿到数据. 所以它并不是真正的Ajax, Ajax是异步的, 它是同步的.
```

#### 33.将数字 12345678 转化成 RMB形式 如： 12,345,678

```js
function formatNumberToRMB ( number ) {
    var str = number + '';
    var arr = str.split('').reverse(); //[8,7,6,5,4,3,2,1]
    var resultArr = [];
    for( var i = 0; i < arr.length; i++ ) {
        resultArr.push( arr[i] );
        if( (i + 1) % 3 == 0 && (i + 1) != arr.length ){
            resultArr.push(',');
        }
    }
    return resultArr.reverse().join('');
}
```

#### 34.**请写一个阻止冒泡的兼容函数**

```js
function stopPropagation ( e ) {
    e = window.event ? window.event : e;
    if( e.stopPropagation ) {
        e.stopPropagation();
    }else{
        e.cancelBubble = true;
    }
}
```

#### 35.**你如何优化自己的代码？**

```js
1.代码重用（函数封装）
2.避免使用过多的全局变量（命名空间，封闭空间，模块化mvc..）
3.拆分函数避免函数过于臃肿：单一职责原则
4.将面向过程的编程方式改为使用面向对象编程
5.适当的注释，尤其是一些复杂的业务逻辑或者是计算逻辑，都应该写出这个业务逻辑的具体过程
6.内存管理，尤其是闭包中的变量释放
```

#### 36.(惑)**列举你用过的设计模式及其场景**

在《JavaScript设计模式与开发实践》这本书中,介绍的设计模式有以下几种：

> 单例模式 | 策略模式 | 代理模式 | 迭代器模式 | 发布-订阅模式 | 命令模式 | 组合模式 | 模板方法模式 | 享元模式 | 职责链模式 | 中介者模式 | 装饰者模 | 状态模式 | 适配模式

####37. 简述event.stopImmediatePropagation和event.stopPropagation的不同

```js
两者都有阻止冒泡的作用, 但是event.stopImmediatePropagation还会阻止该元素绑定的相同类型事件的后续执行
```

#### 38.(待)**列举任一你使用的jquery和zepto插件,并说明实现原理及用途**

#### 39.**请用正则表达式将http://baidu.com/s?wd=yourname&id=21&ie=utf-8**中的id值提取出来

```js
var str = "http://baidu.com/s?wd=yourname&id=21&ie=utf-8";
var regexp = /id=(\w)*/gi;
var idValue = str.match(regexp)[0].split("=")[1];
```

#### 40.**重写setTimeout方法, 实现其回调函数传参setTimeout( function(){} , 1000, param...)(其中param..是function()回调函数的参数)**

```js
var __sto = setTimeout;
window.setTimeout = function (callback, timeout, param) {
    var args = Array.prototype.slice.call(arguments, 2);
    var _cb = function () {
        callback.apply(null, args);
    }
    __sto(_cb, timeout);
}
```

#### 41.**移动端有哪些原生触摸事件?**

```js
1.touch类: touchstart, touchmove, touchend, touchcancel
2.tap类: tap, longTap, singleTap, doubleTap
3.swipe类: swipe, swipeLeft, swipeRight, swipeUp, swipeDown
```

#### 42.分别阐述split(),slice(),splice(),join(),trim(),substr(),substring()？

```js
join()用于把数组中的所有元素拼接起来放入一个字符串。所带的参数为分割字符串的分隔符，默认是以逗号分开。归属于Array
split()即把字符串分离开，以数组方式存储。归属于Stringstring
slice() 方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()
splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。返回的是含有被删除的元素的数组。
trim() 删除字符串开始和末尾的空格.
substr() 的参数指定的是子串的开始位置和长度，因此它可以替代 substring() 和 slice() 来使用。
substring() 方法返回的子串包括 开始 处的字符，但不包括 结束 处的字符。
```

#### 43.添加 删除 替换 插入到某个接点的方法？

```js
obj.appendChild()
obj.removeChild()
obj.replaceChild()
obj.insertBefore()
```

#### 44.你用过require.js吗？它有什么特性？

```js
（1）实现js文件的异步加载，避免网页失去响应；
（2）管理模块之间的依赖性，便于代码的编写和维护。
```

#### 45.在JS中有哪些会被隐式转换为false?

```js
Undefined、null、关键字false、NaN、零、空字符串
```

#### 46.外部JS文件出现中文字符，会出现什么问题，怎么解决？

```js
会出现乱码，加charset=”GB2312”;
```

#### 47.IE和DOM事件流的区别

```js
事件流：事件流描述的是从页面中接收事件的顺序。

事件流的种类：
（事件流主要分为三种）
事件冒泡流(IE事件流)：事件开始时由最具体的元素(文档中嵌套最深的那个节点)接收，然后逐级向上传播到较为不具体的节点(文档)
事件捕获流(Netscape事件流)：不太具体的节点最先接收到事件，而最具体的节点应该最后接收到事件(在事件到达预定目标之前捕获到)
DOM事件流：事件流包括三个阶段，事件捕获阶段，处于目标阶段，事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会；然后是实际的目标接收事件；最后是冒泡阶段，可以在这个阶段对事件做出响应。

IE和DOM事件流的区别：
1.执行的顺序不一样：事件流的执行顺序不一样
案例为：
<body>
   <div>
     <button id = 'btn'>点击<button>
   </div>
</body>
三种事件流分别是：
冒泡型事件模型(IE事件流)： button->div->body
捕获型事件模型(Netscape事件流)： body->div->button
DOM事件模型： body->div->button->button->div->body (先捕获后冒泡)

2.IE和DOM事件侦听函数的区别：
IE使用: 
[Object].attachEvent("name_of_event_handler", fnHandler); //绑定函数 
[Object].detachEvent("name_of_event_handler", fnHandler); //移除绑定 
DOM使用： 
[Object].addEventListener("name_of_event", fnHandler, bCapture); //绑定函数 
[Object].removeEventListener("name_of_event", fnHandler, bCapture); //移除绑定 

3.事件参数不一样和this指向不一样
如上的两个不一样的事件侦听函数：
attachEvent接受两个参数，第一个参数是事件名称，第二个fnHandler是回调处理函数
注意：IE下利用attachEvent注册的处理函数调用时this指向不再是先前注册事件的元素，这时的this为window对象了
addEventListener方法接受三个参数：
第一个参数是事件名称，值得注意的是，这里事件名称与IE的不同，事件名称是没’on’开头的;
第二个参数fnHandler是回调处理函数;
第三个参数注明该处理回调函数是在事件传递过程中的捕获阶段被调用还是冒泡阶段被调用
注意：它可以在一个DOM元素上绑定多个事件处理器，并且在处理函数内部，this关键字仍然指向被绑定的DOM元素，另外处理函数参数列表的第一个位置传递事件event对象
```

####48.call、apply和bind方法的用法以及区别

```js
call 方法第一个参数是要绑定给this的值，后面传入的是一个参数列表。当第一个参数为null、undefined的时候，默认指向window。
apply接受两个参数，第一个参数是要绑定给this的值，第二个参数是一个参数数组。当第一个参数为null、undefined的时候，默认指向window。
和call很相似，第一个参数是this的指向，从第二个参数开始是接收的参数列表。区别在于bind方法返回值是函数以及bind接收的参数列表的使用。
```







### 四、js高级部分

#### 1.**请将一个URL的search部分参数与值转换成一个json对象？**

```js
 function getJsonFromUrlSearch ( search ) {

    var item;
    var result = {};
    
    if( search.indexOf( '&' ) < 0){
        item = search.split( '=' );
        result[ item[ 0 ] ] = item[ 1 ];
        return JSON.stringify( result );
    }

    var splitArray = search.split( '&' );
    
    for( var i = 0; i < splitArray.length; i++ ){
        item = splitArray[ i ].split( '=' );
        result[ item[ 0 ] ] = item[ 1 ];
    }

    return JSON.stringify( result );
    
}
```

#### 2.**请实现jQuery的Ajax请求函数:**

```js
var $ = {
    //把对象转成http协议要求的字符串
    param: function( obj ){

        var html = '';
        for ( var key in obj ){
            html += key + '=' + obj[ key ] + '&';
        }
        html = html.slice( 0, -1 );
        return html;

    },

    //封装ajax方法,参数是一个对象的形式
    ajax: function( option ) {

        var type = option.type || 'get',
        var url  = option.url || '',
        var data = this.param( option.data || {} );
        var success = option.success;

        //实例化对象
        var xhr = new XMLHttpRequest();
        
        //设置请求行
        if( type == 'get' ){
            url = url + '?' + data;
            data = null;
        }
        xhr.open( type, url );
        
        //设置请求头
        if( type == 'post' ){
            xhr.setRequestHeader( 'Content-Type', 'application/x-www-form-urlencoded' );
        }
        
        //设置请求正文
        xhr.send( data );
        
        //监听并处理响应
        xhr.onreadystatechange = function() {
            if( xhr.readyState == 4 && xhr.status == 200 ){
                success( xhr.responseText );
            }
        }

    }   
    
}  
```

#### 3.(待)**请简要描述web前端性能需要考虑哪方面，你的优化思路是什么？**

#### 4.**Promise对象有哪些状态?**

```js
1.pending:初始状态, 不是成功或失败状态
2.fulfilled (也叫resolved): 意味着操作成功完成
3.rejected: 意味着操作失败

Promise对象只能从pengding状态变成fulfilled状态, 或者pending状态变成rejected状态. 不会有其他状态之间的转变.
```

#### 5.**babel和browserify的作用分别是什么?**

```js
babel是一个编译器, 可以把ES6, ES7或者React的JSX语法编译成为ES5的语法, 实现浏览器的兼容.

browserify 能够让浏览器兼容CommonJS规范的require()方法,以此让你的代码中使用require()实现模块依赖的代码能够正常执行.
```

#### 6.请写一个函数,用来实现对象的深拷贝?

```js
function deepClone( obj ){
    return JSON.parse( JSON.stringify( obj ) );
}
```

#### 7.在Javascript中什么是伪数组？如何将伪数组转化为标准数组？

```js
伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。
典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。
```

####8.《正则》写出正确的正则表达式匹配固话号，区号3-4位，第一位为0，中横线，7-8位数字，中横线，3-4位分机号格式的固话号

```js
/^[0]\d{2,3}\-\d{7,8}\-\d{3,4}$/
```

####9.写出代码对下列数组去重并从大到小排列{5,2,3,6,8,6,5,4,7,1,9}

```js
function fn(arr){
    for (var i = 0; i < arr.length-1; i++) {
        for (var j = 0; j < arr.length-1-i; j++) {
            if(arr[j]<arr[j+1]){
                var temp = arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }

        }

    }
    for (var i = 0; i < arr.length; i++) {
        var c=arr[i];
        for (var s = i+1; s < arr.length; s++) {
            if(arr[s]==c){
                //debugger;
                arr.splice(s,1);
                s--;
            }

        }
    }

    return arr;
}
console.log(fn([5,2,3,6,8,6,5,4,7,1,9]).toString());
```

#### 10.**请分别封装添加事件和移除事件的函数，用以解决兼容性问题？**

```js
function addEvent(elem, eventName, handler) {
　　if (elem.attachEvent) {
　　　　elem.attachEvent("on" + eventName,function(){
　　　　　　handler.call(elem)}); 　 //此处使用回调函数call()，让this指向elem　　
  } else if (elem.addEventListener) {
　　    elem.addEventListener(eventName, handler, false);　　
  }
}
function removeEvent(elem, eventName, handler) {
  if (elem.detachEvent) {
  　　elem.detachEvent("on" + eventName,function(){
  　　　   handler.call(elem)}); 　　　　//此处使用回调函数call()，让this指向elem　　
  } else if (elem.removeEventListener) {
  　　elem.removeEventListener(eventName, handler, false);　　
  }
}
//IE提供了attachEvent和detachEvent两个接口，而Firefox提供的是addEventListener和removeEventListener。
```

#### 11.**写一个function，清除字符串前后的空格。（兼容所有浏览器）？**

```js
if (!String.prototype.trim) { 
     String.prototype.trim = function() { 
         return this.replace(/^\s+/, "").replace(/\s+$/,"");
 } 
} 
```

#### 12.JQuery一个对象可以同时绑定多个事件，这是如何实现的？

```js
jQuery可以给一个对象同时绑定多个事件，低层实现方式是使用addEventListner或attachEvent兼容不同的浏览器实现事件的绑定，这样可以给同一个对象注册多个事件。
```

####**13.前端templating(Mustache, underscore,handlebars)是干嘛的, 怎么用?**

```js
Web 模板引擎是为了使用户界面与业务数据（内容）分离而产生的，
Mustache 是一个 logic-less （轻逻辑）模板解析引擎，它的优势在于可以应用在 Javascript、PHP、Python、Perl 等多种编程语言中。
Underscore封装了常用的JavaScript对象操作方法，用于提高开发效率。
Handlebars 是 JavaScript 一个语义模板库，通过对view和data的分离来快速构建Web模板。
```

####14.（待）简述一下Handlebars 的基本用法？简述一下Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？

#### 15.（待）我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，你来说下会执行几次事件，然后会先执行冒泡还是捕获？

#### 16.实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制

```js
•	考察点1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚
•	考察点2：是否知道如何判断一个变量是什么类型的
•	考察点3：递归算法的设计
	// 方法一：
Object.prototype.clone = function(){
   var o = this.constructor === Array ? [] : {};
   for(var e in this){
      o[e] = typeof this[e] === "object" ? this[e].clone() : this[e];
   }
   return o;
}
//方法二：
     /**
     * 克隆一个对象
     * @param Obj
     * @returns
     */
    function clone(Obj) {   
        var buf;   
        if (Obj instanceof Array) {   
            buf = [];//创建一个空的数组 
            var i = Obj.length;   
            while (i--) {   
                buf[i] = clone(Obj[i]);   
            }   
            return buf;    
        }else if (Obj instanceof Object){   
            buf = {};//创建一个空对象 
            for (var k in Obj) { //为这个对象添加新的属性 
                buf[k] = clone(Obj[k]);   
            }   
            return buf;   
        }else{ //普通变量直接赋值
            return Obj;   
        }   
    }

```

####17.小贤是一条可爱的小狗(Dog)，它的叫声很好听(wow)，每次看到主人的时候就会乖乖叫一声(yelp)。

```js
从这段描述可以得到以下对象：
	function Dog() {
      this.wow = function() {
               alert(’Wow’);
      }
      this.yelp = function() {
              this.wow();
      }
}
小芒和小贤一样，原来也是一条可爱的小狗，可是突然有一天疯了(MadDog)，一看到人就会每隔半秒叫一声(wow)地不停叫唤(yelp)。请根据描述，按示例的形式用代码来实。（继承，原型，setInterval）
	function MadDog() {
    this.yelp = function() {
          var self = this;          
          setInterval(function() {
                self.wow();      
          }, 500);
      }
}
MadDog.prototype = new Dog();         
//for test
var dog = new Dog();
dog.yelp();
var madDog = new MadDog();
madDog.yelp();
```

#### 18.原生JS的window.onload与Jquery的$(document).ready(function(){})有什么不同？如何用原生JS实现JQ的ready方法？

```js
window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。
$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。

/*
 * 传递函数给whenReady()
 * 当文档解析完毕且为操作准备就绪时，函数作为document的方法调用
 */
var whenReady = (function() {               //这个函数返回whenReady()函数
    var funcs = [];             //当获得事件时，要运行的函数
    var ready = false;          //当触发事件处理程序时,切换为true
    //当文档就绪时,调用事件处理程序
    function handler(e) {
        if(ready) return;       //确保事件处理程序只完整运行一次
        //如果发生onreadystatechange事件，但其状态不是complete的话,那么文档尚未准备好
        if(e.type === 'onreadystatechange' && document.readyState !== 'complete') {
            return;
        }
        //运行所有注册函数
        //注意每次都要计算funcs.length
        //以防这些函数的调用可能会导致注册更多的函数
        for(var i=0; i<funcs.length; i++) {
            funcs[i].call(document);
        }
        //事件处理函数完整执行,切换ready状态, 并移除所有函数
        ready = true;
        funcs = null;
    }
    //为接收到的任何事件注册处理程序
    if(document.addEventListener) {
        document.addEventListener('DOMContentLoaded', handler, false);
        document.addEventListener('readystatechange', handler, false);            //IE9+
        window.addEventListener('load', handler, false);
    }else if(document.attachEvent) {
        document.attachEvent('onreadystatechange', handler);
        window.attachEvent('onload', handler);
    }
    //返回whenReady()函数
    return function whenReady(fn) {
        if(ready) { fn.call(document); }
        else { funcs.push(fn); }
    }
})();
如果上述代码十分难懂，下面这个简化版：
function ready(fn){
    if(document.addEventListener) {//标准浏览器
        document.addEventListener('DOMContentLoaded', function() {
            //注销事件, 避免反复触发
            document.removeEventListener('DOMContentLoaded',arguments.callee, false);
            fn();//执行函数
        }, false);
    }else if(document.attachEvent) {//IE
        document.attachEvent('onreadystatechange', function() {
            if(document.readyState == 'complete') {
                document.detachEvent('onreadystatechange', arguments.callee);
                fn();//函数执行
            }
        });
    }
};
```

#### 19.（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）



```js
回答出概念即可，下面是几个要点
1.	给需要拖拽的节点绑定mousedown, mousemove, mouseup事件
2.	mousedown事件触发后，开始拖拽
3.	mousemove时，需要通过event.clientX和clientY获取拖拽位置，并实时更新位置
4.	mouseup时，拖拽结束
5.	需要注意浏览器边界的情况
```

#### 24.Javascript作用链域?

```js
理解变量和函数的访问范围和生命周期，全局作用域与局部作用域的区别，JavaScript中没有块作用域，函数的嵌套形成不同层次的作用域，嵌套的层次形成链式形式，通过作用域链查找属性的规则需要深入理解。
```

#### 25.eval是做什么的？

```js
它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2个步骤，一次解析成js语句，一次执行）
```

####26.new操作符具体干了什么呢?

```js
1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
2、属性和方法被加入到 this 引用的对象中。
3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。
```

#### 27.js延迟加载的方式有哪些？

```js
方案一：<script>标签的async="async"属性
方案二：<script>标签的defer="defer"属性
方案三：动态创建<script>标签
方案四：AJAX eval（使用AJAX得到脚本内容，然后通过eval_r(xmlhttp.responseText)来运行脚本）
方案五：iframe方式
```

####28.(待)AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？

```js
理解这两种规范的差异，主要通过requirejs与seajs的对比，理解模块的定义与引用方式的差异以及这两种规范的设计原则
```

#### 29.（待）requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）

#### 30.（待）让你自己设计实现一个requireJS，你会怎么做？

#### 31.DOM操作——怎样添加、移除、移动、复制、创建和查找节点?

```js
（1）创建新节点
      createDocumentFragment()    //创建一个DOM片段
      createElement_x()   //创建一个具体的元素
      createTextNode()   //创建一个文本节点
（2）添加、移除、替换、插入
      appendChild()
      removeChild()
      replaceChild()
      insertBefore()
（3）查找
      getElementsByTagName()    //通过标签名称
      getElementsByName()    //通过元素的Name属性的值
      getElementById()    //通过元素Id，唯一性
```

#### 32.数组和对象有哪些原生方法，列举一下？

```js
Array.concat( ) 连接数组 
Array.join( ) 将数组元素连接起来以构建一个字符串 
Array.length 数组的大小 
Array.pop( ) 删除并返回数组的最后一个元素 
Array.push( ) 给数组添加元素 
Array.reverse( ) 颠倒数组中元素的顺序 
Array.shift( ) 将元素移出数组 
Array.slice( ) 返回数组的一部分 
Array.sort( ) 对数组元素进行排序 
Array.splice( ) 插入、删除或替换数组的元素 
Array.toLocaleString( ) 把数组转换成局部字符串 
Array.toString( ) 将数组转换成一个字符串 
Array.unshift( ) 在数组头部插入一个元素

Object.hasOwnProperty( ) 检查属性是否被继承 
Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型 
Object.propertyIsEnumerable( ) 是否可以通过for/in循环看到属性 
Object.toLocaleString( ) 返回对象的本地字符串表示 
Object.toString( ) 定义一个对象的字符串表示 
Object.valueOf( ) 指定对象的原始值
```

#### 32.如何编写高性能的Javascript？

```js
使用 DocumentFragment 优化多次 append
通过模板元素 clone ，替代 createElement
使用一次 innerHTML 赋值代替构建 dom 元素
使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素 
使用 Array 做为 StringBuffer ，代替字符串拼接的操作 
将循环控制量保存到局部变量
顺序无关的遍历时，用 while 替代 for
将条件分支，按可能性顺序从高到低排列
在同一条件子的多（ >2 ）条件分支时，使用 switch 优于 if
使用三目运算符替代条件分支 
需要不断执行的时候，优先考虑使用 setInterval
```

#### 33.javascript对象的几种创建方式？

```js
1. 工厂模式
2. 构造函数模式
3. 原型模式
4. 混合构造函数和原型模式
5. 动态原型模式
6. 寄生构造函数模式
7. 稳妥构造函数模式
```

#### 34.javascript继承的 6 种方法？

```js
1. 原型链继承
2. 借用构造函数继承
3. 组合继承(原型+借用构造)
4. 原型式继承
5. 寄生式继承
6. 寄生组合式继承
```

#### 35.eval是做什么的？

```js
1. 它的功能是把对应的字符串解析成JS代码并运行
2. 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）
```

#### 36.(待)JavaScript原型，原型链 ? 有什么特点？

#### 37.写一个通用的事件侦听器函数

```js
// event(事件)工具集，来源：https://github.com/markyun
markyun.Event = {
    // 页面加载完成后
    readyEvent : function(fn) {
        if (fn==null) {
            fn=document;
        }
        var oldonload = window.onload;
        if (typeof window.onload != 'function') {
            window.onload = fn;
        } else {
            window.onload = function() {
                oldonload();
                fn();
            };
        }
    },
    // 视能力分别使用dom0||dom2||IE方式 来绑定事件
    // 参数： 操作的元素,事件名称 ,事件处理程序
    addEvent : function(element, type, handler) {
        if (element.addEventListener) {
            //事件类型、需要执行的函数、是否捕捉
            element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
            element.attachEvent('on' + type, function() {
                handler.call(element);
            });
        } else {
            element['on' + type] = handler;
        }
    },
    // 移除事件
    removeEvent : function(element, type, handler) {
        if (element.removeEnentListener) {
            element.removeEnentListener(type, handler, false);
        } else if (element.datachEvent) {
            element.detachEvent('on' + type, handler);
        } else {
            element['on' + type] = null;
        }
    }, 
    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
    stopPropagation : function(ev) {
        if (ev.stopPropagation) {
            ev.stopPropagation();
        } else {
            ev.cancelBubble = true;
        }
    },
    // 取消事件的默认行为
    preventDefault : function(event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    },
    // 获取事件目标
    getTarget : function(event) {
        return event.target || event.srcElement;
    },
    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
    getEvent : function(e) {
        var ev = e || window.event;
        if (!ev) {
            var c = this.getEvent.caller;
            while (c) {
                ev = c.arguments[0];
                if (ev && Event == ev.constructor) {
                    break;
                }
                c = c.caller;
            }
        }
        return ev;
    }
}; 

```

####38.Jquery与jQuery UI 有啥区别？

```js
*jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。
*jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。
提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等
```





### 五、HTTP和Ajax面试题

#### 1.解释jsonp的原理，以及为什么不是真正的ajax？

```js
JSONP 的原理：通过<script>标签向服务器发送请求，将前端函数名称作为参数传递到服务器，服务器接收到请求后将 JSON 数据作为该方法的参数，返回 JavaScript 文本，前端方法就可以拿到数据。
ajax是异步的,jsonp是同步的,所以它并不是真正的ajax
```

#### 2.**请描述一下cookies，sessionStorage和localStorage的区别?**

```js
1.sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁. 因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储.
2.localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
3.Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。
```

#### 3.**如何解决跨域问题?**

```http
1.JSOP跨域
2.CROS跨域
3.反向代理

理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域

出于安全考虑，服务器不允许ajax跨域获取数据，但是可以跨域获取文件内容，所以基于这一点，可以动态创建script标签，使用标签的src属性访问js文件的形式获取js脚本，并且这个js脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据，为了获取这里的参数数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据，这就是解决跨域问题的主流解决方案
```

#### 4.**简述ajax 的过程**

```js
1.创建XMLHttpRequest对象,也就是创建一个异步调用对象
2.创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
3.设置响应HTTP请求状态变化的函数
4.发送HTTP请求
5.获取异步调用返回的数据
6.使用JavaScript和DOM实现局部刷新
```

#### 5.(待)**http常见的状态码有那些？分别代表是什么意思？**

```http
200 - 请求成功
301 - 资源（网页等）被永久转移到其它URL
400 Bad Request  //客户端请求有语法错误，不能被服务器所理解
403 Forbidden  //服务器收到请求，但是拒绝提供服务
404 Not Found  //请求资源不存在，输入了错误的URL
500 Internal Server Error //服务器发生不可预期的错误
503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常

100-199 用于指定客户端应相应的某些动作。 
200-299 用于表示请求成功。 
300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 
400-499 用于指出客户端的错误。
400  语义有误，当前请求无法被服务器理解。
401  当前请求需要用户验证 
403  服务器已经理解请求，但是拒绝执行它。
500-599 用于支持服务器错误。 
503 – 服务不可用

```

#### 6. 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

```http
分为以下4个步骤：

1.当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。

2.浏览器与远程 Web 服务器通过TCP三次握手协商来建立一个TCP/IP连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。

3.一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的GET请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。

4.此时，Web 服务器提供资源服务，客户端开始下载资源。
```

#### 7. ***jQuery中的全局Ajax事件有哪些？

```js
ajaxComplete()
ajaxError()
ajaxSend()
ajaxStart()
ajaxStop()
ajaxSuccess()
```

#### 8.**HTTP协议目前常用的有哪几个？KEEPALIVE从哪个版本开始出现的？**

```js
HTTP协议目前常用的有1.0和1.1版本, KEEPALIVE是1.1版本才开始出现的

现在1.1版本默认支持KEEPALIVE
-HTTP1.0需要在request中增加“Connection：keep-alive” header才能够支持
```

#### 9.**请列举出几个你所知道的模板引擎？**

```http
art-template(腾讯)  https://github.com/aui/art-template
BaiduTemplate(百度) http://baidufe.github.io/BaiduTemplate/
Velocity(阿里)      https://github.com/shepherdwind/velocity.js
Handlebars          http://handlebarsjs.com
```

#### 10.页面编码和被请求的资源编码如果不一致如何处理？

```
对于ajax请求传递的参数，如果是get请求方式，参数如果传递中文，在有些浏览器会乱码，不同的浏览器对参数编码的处理方式不同，所以对于get请求的参数需要使用 encodeURIComponent函数对参数进行编码处理，后台开发语言都有相应的解码api。对于post请求不需要进行编码
```

####11.阐述一下异步加载？异步加载的方式？

```
1. 异步加载的方案： 动态插入 script 标签
2. 通过 ajax 去获取 js 代码，然后通过 eval 执行
3. script 标签上添加 defer 或者 async 属性
4. 创建并插入 iframe，让它异步执行 js

异步加载的方式：
(1) defer，只支持IE
(2) async：
(3) 创建script，插入到DOM中，加载完毕后callBack
      documen.write和 innerHTML的区别
      document.write只能重绘整个页面
      innerHTML可以重绘页面的一部分

```

#### 12. Ajax的最大的特点是什么?ajax的缺点?

```
Ajax可以实现异步通信效果，实现页面局部刷新，带来更好的用户体验；按需获取数据，节约带宽资源

 缺点：
 1、ajax不支持浏览器back按钮。
 2、安全问题 AJAX暴露了与服务器交互的细节。
 3、对搜索引擎的支持比较弱。
 4、破坏了程序的异常机制。
```

#### 13.什么是Ajax和JSON，它们的优缺点？

```
Ajax是全称是asynchronous JavaScript andXML，即异步JavaScript和xml，用于在Web页面中实现异步数据交互，实现页面局部刷新。
优点：可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量，避免用户不断刷新或者跳转页面，提高用户体验
缺点：对搜索引擎不友好；要实现ajax下的前后退功能成本较大；可能造成请求数的增加跨域问题限制；

JSON是一种轻量级的数据交换格式，ECMA的一个子集
优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字）
```

#### 14.ajax请求时，如何解释json数据

```json
使用eval() 或者JSON.parse() 鉴于安全性考虑，推荐使用JSON.parse()更靠谱，对数据的安全性更好。
```

#### 15.为什么利用多个域名来存储网站资源会更有效？

```json
确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他域名访问网站，并且不同的资源放到不同的服务器上有利于减轻单台服务器的压力。
```

#### 16.请说出三种减低页面加载时间的方法

```
1、压缩css、js文件
2、合并js、css文件，减少http请求
3、外部js、css文件放在最底下
4、减少dom操作，尽可能用变量替代不必要的dom操作
```

#### 17.对JSON的了解？

```json
轻量级数据交互格式，可以形成复杂的嵌套格式，解析非常方便
```

#### 18.WEB应用从服务器主动推送Data到客户端有那些方式？

```
html5 websoket
WebSocket通过Flash
XHR长时间连接
XHR Multipart Streaming
不可见的Iframe
<script>标签的长时间连接(可跨域)
```





### 六、兼容性问题面试题合集

#### 1.**Polyfill是什么?**

```js
Polyfill的准确意思为：用于实现浏览器并不支持的原生API的代码。
例如，querySelectorAll是很多现代浏览器都支持的原生Web API，但是有些古老的浏览器并不支持，那么假设有人写了库，只要用了这个库， 你就可以在古老的浏览器里面使用document.querySelectorAll，使用方法跟现代浏览器原生API无异。那么这个库就可以称为Polyfill或者Polyfiller。
那么问题就来了。jQuery是不是一个Polyfill?答案是No。因为它并不是实现一些标准的原生API，而是封装了自己API。一个Polyfill是抹平新老浏览器 标准原生API 之间的差距的一种封装，而不是实现自己的API。
已有的一些Polyfill，如 Polymer 是让旧的浏览器也能用上 HTML5 Web Component 的一个Polyfill。FlashCanvas是用Flash实现的可以让不支持Canvas API的浏览器也能用上Canvas的Polyfill。
```

这里有一堆Polyfills，有兴趣可以把玩一下：[HTML5 Cross Browser Polyfills](https://link.jianshu.com/?t=https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills)

#### 2.**Modernizr、HTML5Shiv、respond.js三者的区别？**

```
1.HTML5Shiv主要解决HTML5提出的新的元素不被IE6-8识别。

2.Respond.js 是一个快速、轻量的 polyfill，用于为 IE6-8 以及其它不支持 CSS3 Media Queries 的浏览器提供媒体查询的 min-width 和 max-width 特性，实现响应式网页设计（Responsive Web Design）。

3.Modernizr 是一个开源的JS库，最初主要用于检测浏览器的新特性支持情况，现在默认包含了html5shiv的能力。它使得设计师可以在支持HTML5和CSS3的浏览器中充分利用HTML5和CSS3的特性进行开发，同时又不会牺牲其他不支持这些新技术的浏览器的控制。

总结:
一般情况下HTML5Shiv、respond这2个搭配使用。
Modernizr 包括那2个，并且比他们更强大一些。
```

#### 3.**webSocket如何兼容低浏览器？(阿里面试题)**

```
Adobe Flash Socket 、
ActiveX HTMLFile (IE) 、
基于 multipart 编码发送 XHR 、
基于长轮询的 XHR
```

#### 4.**经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？**

```
1.png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.

2.浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。

3.IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;Firefox下,只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。

4.IE下,even对象有x,y属性,但是没有pageX,pageY属性;Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。
```

```js
//解决方案：
var page = {};
page.x = event.x ? event.x : event.pageX;
page.y = event.y ? event.y:event.pageY;
```

```
5.Chrome 中文界面下默认会将小于12px的文本强制按照12px显示,可通过加入CSS属性-webkit-text-size-adjust: none; 解决。

6.超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}
```

#### 5.如何优化网页加载速度？

```
1.减少css，js文件数量及大小(减少重复性代码，代码重复利用)，压缩CSS和Js代码
2.图片的大小
3.把css样式表放置顶部，把js放置页面底部	
4.减少http请求数
5.使用外部 Js 和 CSS
```





## 七、前端代码测试

#### 1.（待）如何测试前端代码? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?

#### 2.前端开发的优化问题（看雅虎14条性能优化原则）。

```
（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。
（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数
（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。
（4） 当需要设置的样式很多时设置className而不是直接操作style。
（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。
（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。
（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。
（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。
```





## 八、流行框架

#### 1.jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？

```
this执行init构造函数自身，其实就是jQuery实例对象，返回this是为了实现jQuery的链式操作
```

#### 2.jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？

```
递归赋值
```

#### 3.jquery.extend 与 jquery.fn.extend的区别？

```
Jquery.extend用来扩展jQuery对象本身；jquery.fn.extend用来扩展jQuery实例
```

#### 4.（待）谈一下Jquery中的bind(),live(),delegate(),on()的区别？

#### 5.针对 jQuery 的优化方法？

```
优先使用ID选择器
在class前使用tag(标签名)
给选择器一个上下文
慎用 .live()方法（应该说尽量不要使用）
使用data()方法存储临时变量
```

#### 6.Zepto的点透问题如何解决？

```
点透主要是由于两个div重合，例如：一个div调用show()，一个div调用hide()；这个时候当点击上面的div的时候就会影响到下面的那个div；
解决办法主要有2种：
1.github上有一个叫做fastclick的库，它也能规避移动设备上click事件的延迟响应，https://github.com/ftlabs/fastclick
将它用script标签引入页面（该库支持AMD，于是你也可以按照AMD规范，用诸如require.js的模块加载器引入），并且在dom ready时初始化在body上，
2.根据分析，如果不引入其它类库，也不想自己按照上述fastclcik的思路再开发一套东西，需要1.一个优先于下面的“divClickUnder”捕获的事件；2.并且通过这个事件阻止掉默认行为（下面的“divClickUnder”对click事件的捕获，在ios的safari，click的捕获被认为和滚屏、点击输入框弹起键盘等一样，是一种浏览器默认行为，即可以被event.preventDefault()阻止的行为）。
```

#### 7.（待）Underscore对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？







## 九、移动App开发

#### 1.移动端最小触控区域是多大？

```
移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。）
```





## 十、NodeJs

#### 1.对Node的优点和缺点提出了自己的看法：

```
*（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，
因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。
此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，
因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。

*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，
而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。
```

#### 2.（待）需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？

```
至少给出自己的思路（url-hash,可以使用已有的一些框架history.js等）
```

#### 3.Node.js的适用场景？

```
1)、实时应用：如在线聊天，实时通知推送等等（如socket.io）
2)、分布式应用：通过高效的并行I/O使用已有的数据
3)、工具类应用：海量的工具，小到前端压缩部署（如grunt），大到桌面图形界面应用程序
4)、游戏类应用：游戏领域对实时和并发有很高的要求（如网易的pomelo框架）
5)、利用稳定接口提升Web渲染能力
6)、前后端编程语言环境统一：前端开发人员可以非常快速地切入到服务器端的开发（如著名的纯Javascript全栈式MEAN架构）
```

#### 4.对BFC规范的理解？

```
BFC（块级格式化上下文），一个创建了新的BFC的盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素。在同一个BFC中的两个相邻的盒子在垂直方向发生margin重叠的问题。

BFC是指浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用
```

