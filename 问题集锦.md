### 一、Html部分:

#### 1.为什么不能定义1px左右的div容器

```html
IE6下这个问题是因为默认的行高造成的，解决的方法也有很多，例如：
overflow:hidden | zoom:0.08 | line-height:1px
```

#### 2.简述readyonly与disabled的区别

```html
ReadOnly和Disabled的作用是使用户不能够更改表单域中的内容.
但是二者还是有着一些区别的：
1、Readonly只针对input(text/password)和textarea有效，而disabled对于所有的表单元素有效，包括select,radio,checkbox,button等。
2、在表单元素使用了disabled后，我们将表单以POST或者GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去
```

#### 3.**XHTML 与 HTML 有什么区别？**

```html
XHTML元素必须被正确的嵌套
XHTML元素必须被关闭,单标签也得关闭. 例如<br/>
标签名必须使用小写
XHTML文档必须具备根元素
```

#### 4.**对Web标准以及W3C的理解和认识**

```html
1.标签闭合,标签小写,不乱嵌套,提高搜索机器人搜索几率,使用外链CSS和js脚本,结构行为表现的分离.
2.文件下载与页面速度更快,内容能被更多的用户所访问, 内容能被广泛的设备所访问,更少的代码和组件
3.容易维护, 改版方便, 不需要变动页面内容, 提供打印版本而不需要复制内容, 提高网站易用性.
```

#### 5.**iframe的作用**

```html
iframe是用来在网页中插入第三方网页,早起的页面使用iframe主要是用于到导航栏这种很多页面都相同的部分, 这样可以在切换页面的时候避免重复加载.现在很少使用了.
```

#### 6. 如何检测页面加载和渲染性能,具体指标有哪些?

##### **基于网页分析工具：**

```js
1.17CE
2.百度移动APP测试服务
3.PingDom Tools
4.https://gtmetrix.com/
```

**基于浏览器分析工具：**

```js
1.Chrome自带工具F12
2.Firefox插件：YSlow（Yahoo工具）
3.Page Speed（google）
```

**具体指标有:**

```js
1.页面加载时间: 从页面开始加载到页面onload事件触发的时间.
2.全部页面加载事件: 最初启动浏览开始, 直到所有元素都被加载完成后, 在2秒后任然没有网络活动的时间.
3.从开始加载到收到服务器返回数据的第一个字节的时间
4.DNS事件: 进行域名解析所需要的时间
5.HTPP网页打分: 页面渲染, 下载速度, 页面流畅度
6.TCP时间: 客户端建立连接的时间
```

####7.列举不少于6条的IE与FF脚本兼容性问题，需要写出命令

```html
(1) window.event： 

表示当前的事件对象，IE有这个对象，FF没有，FF通过给事件处理函数传递事件对象 

(2) 获取事件源 

IE用srcElement获取事件源，而FF用target获取事件源 

(3) 添加，去除事件 

IE：element.attachEvent(“onclick”, function) element.detachEvent(“onclick”, function) 

FF：element.addEventListener(“click”, function, true) element.removeEventListener(“click”, function, true) 

(4) 获取标签的自定义属性 

IE：div1.value或div1[“value”] 

FF：可用div1.getAttribute(“value”) 

(5) document.getElementByName()和document.all[name] 

IE；document.getElementByName()和document.all[name]均不能获取div元素 

FF：可以 

(6) input.type的属性 

IE：input.type只读 

FF：input.type可读写 

(7) innerText textContent outerHTML 

IE：支持innerText, outerHTML 

FF：支持textContent 

(8) 是否可用id代替HTML元素 

IE：可以用id来代替HTML元素 

FF：不可以 
```

#### 8.本地存储（Local Storage ）和cookies（储存在用户本地终端上的数据）之间的区别是什么？

```html
Cookies:服务器和客户端都可以访问；大小只有4KB左右；有有效期，过期后将会删除；

本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST或者GET的通道发送到服务器；每个域5MB；没有过期数据，它将保留知道用户从浏览器清除或者使用Javascript代码移除
```

####9.如何对网站的文件和资源进行优化？

```html
文件合并
文件最小化/文件压缩
使用CDN托管
缓存的使用
```

#### 10.HTML5 Canvas 元素有什么用？

```html
Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作。
```

#### 11.[用H5+CSS3]()解决下导航栏最后一项掉下来的问题

```html
box-sizing: border-box;
```

####  12. 为什么利用多个域名来存储网站资源会更有效？

```html
CDN缓存更方便 
突破浏览器并发限制 
节约cookie带宽 
节约主域名的连接数，优化页面响应速度 
防止不必要的安全问题
```



​    



### 二、css部分：

#### 1.**介绍一下你对浏览器内核的理解?常见的浏览器内核有哪些?以及处理css样式的前缀？**

```css
浏览器内核由两个部分组成,第一部分是渲染引擎, 第二部分是Javascript解析器.
现在主流的内核有4中

Tridnet: IE浏览器, 腾讯浏览器, 遨游浏览器, 360浏览器
Gecko: Firefox浏览器
Webkit: Safari浏览器
Blinke: Chorme浏览器, Opera浏览器

-ms-transform:rotate(7deg);      //  -ms-代表IE浏览器识别前缀
-moz-transform:rotate(7deg);      //  -moz-代表火狐浏览器识别前缀
-webkit-transform:rotate(7deg);    //  -webkit-代表谷歌和Safari浏览器识别前缀
-o-transform:rotate(7deg);          //  -o- 代表Opera浏览器识别前缀

transform;rotate(7deg)           // 统一标识语句，符合w3c标准
```



#### 2.**水平垂直居中的方式有几种?**

```css
1.将margin-left和margin-right设置为auto    margin:0 auto
	<style>
            .child{
                margin: 0 auto;
                width:50px; 
            }
    </style>
2.采用absolute + transform的方式(绝对定位+水平移动)
        <style>
                .parent{
                    position : relative;
                }
                .child{
                    position: absolute;
                    left:50%;
                    top:50%;
                    transform: translate(-50%,-50%);
                }
        </style>
3.采用inline-block + text-align + table-cell + vertical-align(单元格方式)
		<style>
            .parent{
                display:table-cell;
                vertical-align:middle;
                text-align:center;
                width:200px;  /*如果使用该方法,父盒子得设定宽度*/
            }
            .child{
                display:inline-block;
            }
        </style>
```



#### 3.**描述一下CSS中的渐进增强, 优雅降级之间的区别?**

```css
优雅降级指的是为现代浏览器制作网站,然后保证为某些老版本的流浪器提供基于可用的体验. 新特性在老版本浏览器中会降级, 且一般会有一个分界点, 声明不支持哪些老掉牙的浏览器. 有些时候也会警告用户更换其浏览器.

渐进增强与优雅降级相反. 渐进增强一开始就针对低版本浏览器构建页面,然后再针对高级浏览器增加特效和其他交互效果.渐进增强关注内容本身.
```

#### 4.(待)清除浮动的几种方法，及各自的优缺点？

#### 5.**IE盒模型和W3C盒模型有什么不同？**

```css
IE盒模型：margin 、 content（包含border、padding）
W3C盒模型： margin 、border、 padding、 content

CSS3中的box-sizing的属性就是为了这两种模式，border-box（IE盒明星）和content-box（W3C）
```



### 三、Js基础部分：

#### 1.Js解决兼容性的方法？

#### 2.封装函数解析（url解析）

var url = 'http://www.itheima.com/login.html?name=zs&age=18';

得到{
   name: 'zs',
   age: 18
}

```js
<script>
        var url = 'http://www.itheima.com/login.html?name=zs&age=18';

        function getParams(url) {
            var params = {};
            var urls = url.split("?");
            var arr = urls[1].split("&");
            // console.log(arr);
            for (var i = 0; i < arr.length; i++) {
                var arr1 = arr[i].split("=");
                // console.log(arr1);
                params[arr1[0]] = arr1[1];
            }
            // return params;
            console.log(params);
        }
        getParams(url);

    </script>
```



#### 3.es5的迭代方法以及各自的作用?

```js
forEach(),map(),filter(),some(),every()
```



#### 4.window.location的一些常用命令

```js
4.1 window.location.search():会返回当前页面查询字符部分, 也就是url中以?开始的部分.
4.2 window.location.hash:会返回当前页面查询字符部分, 也就是url中以?开始的部分.
4.3 window.location.reload()：刷新当前页面
```



#### 5.**请简述javascript 中的垃圾回收机制**

```js
js在创建对象, 调用函数等操作的时候都会涉及到申请内存, 函数的内存由系统进行管理, 一旦调用结束后内存回收. 但是对象的内存由js引擎进行管理,js中对象具有动态特性,所以js引擎会带有垃圾回收机制.

垃圾回收机制具有释放不使用的内存和整合内存的作用. 然而因为会进行内存的整合, 所以在进行垃圾回收的时候会影响浏览器的性能.浏览器会使用一些算法来确定垃圾回收的时机, Chrome浏览器中采用的是分代回收的方法.
```



#### 6.BOM对象有哪些，列举window对象？

```js
window对象 ，是JS的最顶层对象，其他的BOM对象都是window对象的属性；
document对象，文档对象；
location对象，浏览器当前URL信息；
navigator对象，浏览器本身信息；
screen对象，客户端屏幕信息；
history对象，浏览器访问历史信息；
```

#### 7.bind(), live(), delegate()的区别

```js
bind： 绑定事件，对新添加的事件不起作用，方法用于将一个处理程序附加到每个匹配元素的事件上并返回jQuery对象。
live： 方法将一个事件处理程序附加到与当前选择器匹配的所有元素（包含现有的或将来添加的）的指定事件上并返回jQuery对象。
delegate： 方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素（现有的或将来的）的一个或多个事件上。  
```

#### 8. **普通事件和事件绑定有什么区别?**

```js
1.普通事件:
（1）给html元素添加特定的属性
（2）采用<div onclick="doSomeThing()">点我</div>
（3）采用document.querySelector('div').onclick = function(){}
（4）普通事件只能为同一个元素添加单个事件, 后面的事件会覆盖掉前面的事件

2.事件绑定:
（1）使用addEventListener()添加事件
（2）采用事件绑定可以为其添加多个事件, 其事件的执行顺序是从最先添加的事件开始依次执行
```

#### 9.**addEventListener()和attachEvent()的区别**

```js
（1）addEventListener()是符合W3C规范的标准方法;  attachEvent()是IE低版本的非标准方法
（2）addEventListener()支持事件冒泡和事件捕获; 而attachEvent()只支持事件冒泡
（3）addEventListener()的第一个参数中,事件类型不需要添加on; attachEvent()需要添加'on'
（4）如果为同一个元素绑定多个事件, addEventListener()会按照事件绑定的顺序依次执行, attachEvent()会按照事件绑定的顺序倒序执行.
```

#### 10.**闭包是什么? 有什么特性? 对页面有什么影响?**

```js
1.闭包是什么:闭包是指有权访问另一个函数作用域中变量的函数.
2.闭包有什么特性:
    通过闭包,可以提供私有作用域.
    函数执行完后,内部不会释放
    通过闭包,可以实现带有存储函数运行时变量的函数.
3.对页面有什么影响:
	大量使用闭包会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
```

#### 11.**如何阻止事件冒泡和html标签的默认行为?**

```js
(1) 阻止事件冒泡:
	IE8及以下: window.event.cancelBubble = true
	IE9及以上/Chorme/Firefox: event.stopPropagation()
(2) 阻止html标签的默认行为:
	IE8及以下: window.event.returnValue = false
	IE9及以上/Chorme/Firefox: event.preventDefault()
```

#### 12.**编写一个数组去重的方法**

**方法1:采用数组的filter方法**

```js
function filterRepetition ( arr ) {
    return arr.filter(function ( item, index, array ){
        return array.indexOf( item ) === index;
    })
}
```

**方法2:采用缓存的方法**

```js
function filterRepetition ( arr ) {
    var cache = {};
    var resultArr = [];
    for( var i = 0; i < arr.length; i++ ){
        if( cache[arr[i]] ) {
            continue;
        }else{
            cache[arr[i]] = true;
            resultArr.push( arr[i] );
        }
    }
    return resultArr;
}
```

#### 13.**获取页面所有的checkbox**

```js
var resultArr= [];
var input = document.querySelectorAll('input');
for( var i = 0; i < input.length; i++ ) {
    if( input[i].type == 'checkbox' ) {
        resultArr.push( input[i] );
    }
}
//resultArr即中获取到了页面中的所有checkbox
```

#### 14.**以下代码的输出结果**

```js
console.log( null == undefined ); //true
console.log( null === undefined ); //false
console.log( [] == false ); //true
```

#### 15.**将字符串"<tr><td>{${$name}</td></tr>{$id}"中的{$id}替换成10，{$name}替换成"Tony" （使用正则表达式）**

```js
var str  = '<tr><td>{$id}</td><td>{$name}</td></tr>{$id}';
var newStr = str.replace( /{\$id}/g, 10 ).replace( /{\$name\}/g, 'Tony' );
```

#### 16.**为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将<, >, &, “进行转义**

```js
function escapeHtml ( str ) {
    var exp = /[<>&]/g;
    var newStr = str.replace( exp, function( match ) {
        //该传入什么参数 
        if( match === '<' ) {
            return '<'
        }else if ( match === '>' ) {
            return '&gt'
        }else if ( match ==='&' ) {
            return '&'
        }
    }) 
    return newStr;   
}
```

#### 17.**用js实现随机选取10–100之间的10个数字，存入一个数组，并排序**

```js
function getSortedRandomNumber () {
    var arr = [];
    for( var i = 0; i < 10; i++ ) {
        arr.push( Math.floor( Math.random() * 90 ) + 10 );
    }
    return arr.sort(function ( a, b ) {
        return a - b;
    })
}
```

#### 18.**有这样一个URL：`http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e`，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按`key-value`形式返回到一个json结构中，如`{"a":"1","b":"2","c":"","d":"xxx","e":"undefined"}`**

```js
function getQueryJson ( URLstr ) {
    var queryIndex = URLstr.indexOf('?') + 1;
    var queryStr = URLstr.slice( queryIndex ); //a=1&b=2&c=&d=xxx&e
    var arr = queryStr.split( '&' ); //[ a=1, b=2, c=, d=xxx, e ]
    var obj = {};
    var resultArr =  [];
    for( var i = 0; i < arr.length; i++ ) {
        var tempArr = arr[ i ].split( '=' );
        obj[ tempArr[0] ] = tempArr[1];
    }
    for( var key in obj ){
        resultArr.push( '"' + key + '"' + ':'  + '"' + obj[ key ] + '"'   ); 
    }
    return '{' + resultArr.join(',') + '}'; //{"a":"1","b":"2","c":"","d":"xxx","e":"undefined"}
}
```

- 注意: 如果这道题目最后没有那个`e`,即URL是`http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx`,那么代码可简化为:

  ```js
  function getQueryJson ( URLstr ) {
      var queryIndex = URLstr.indexOf('?') + 1;
      var queryStr = URLstr.slice( queryIndex ); //a=1&b=2&c=&d=xxx&e
      var arr = queryStr.split( '&' ); //[ a=1, b=2, c=, d=xxx, e ]
      var obj = {};
      var resultArr =  [];
      for( var i = 0; i < arr.length; i++ ) {
          var tempArr = arr[ i ].split( '=' );
          obj[ tempArr[0] ] = tempArr[1];
      }
      return JSON.stringify( obj ); //{"a":"1","b":"2","c":"","d":"xxx"}
  }
  ```

#### 19.**看下面代码，给出输出结果**

```js
for(var i=1;i<=3;i++){
  setTimeout(function(){
      console.log(i);    
  },0);  
}
结果: 4, 4, 4
```

**追问 : 如何让代码输出1,2,3? (两种方法)**

- 方法1: 采用立即执行函数

```js
for( var i = 1; i <= 3; i++ ) {
    setTimeout( function( num ) {
        return function () {
            console.log( num );
        }
    } ( i ), 0);
}
```

- 方法2: 采用闭包

```js
for( var i = 1; i <= 3; i++ ) {
    setTimeout( (function (){
        var j = i;
        return function () {
            console.log( j );
        }
    })(), 0);
}
```

#### 20.**写一个function，清除字符串前后的空格。（兼容所有浏览器）**

```js
if( typeof String.prototype.trim !== 'function' ) {
    String.prototype.trim = function( ) {
        return this.replace ( /^\s*|\s*$/g, '' );
    }
}
```

#### 21.**Javascript中callee和caller的作用**

```js
callee是arguments的一个属性,返回的是正在执行的函数的本身的引用
caller返回一个函数的引用，被返回的这个函数调用了当前的函数
```

#### 22.**实现检索当前页面中的表单元素中的所有文本框，并将它们全部清空的函数**

```js
function clearText() {
    var texts = document.getElementsByTagName( 'input' );
    for( var i = 0; i< texts.length; i++ ) {
        if( texts[ i ].type === 'text' ) {
            texts[ i ].value = '';
        }
    }
}
```

#### 23.**写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉**

```js
var reg = /(<\w+>)|(<\/\w+>)/gi;
var str = '<div>这里是div<p>里面的段落</p></div>';
alert(str.replace(reg,""));
```

#### 24.**截取字符串abcdefg的efg**

方法一: 使用String.prototype.slice()方法

```js
var str = "abcdefg";
var newStr = str.slice( 4 );
console.log( newStr );  //efg
```

方法二: 使用String.prototype.substring()方法

```js
var str = "abcdefg";
var newStr = str.substring( 4 );
console.log( newStr ); //efg 
```

#### 25.**列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个**

```js
BOM中常用的对象: window, history, document, location, navigator

BOM对象的常用方法: alert(), confirm(), open(), close(), setTimeout(), setInterval(), clearInterval(), clearTimeout
```

#### 26.(待)**Javascript创建对象的几种方式？**

#### 27.**请你谈谈Cookie的优缺点？**

```js
优点：　
1. 通过良好的编程，可控制保存cookie中的session对象的大小
2. 通过加密和安全传输技术(SSL),可减少cookie被破解的可能性
3. 可在cookie中存放不敏感数据.
4. cookie的生命周期可控, 通过控制cookie的声明周期,让其不会永远有效

缺点:
1. cookie的数量和长度有限.每个特定的域名下最多生成20个cookie,每个cookie长度不能超过4kb
2. 额外开销,cookie在每次发起Http请求的时候都会被发送给服务器,会增加开销
3. 安全性问题,cookie不去拿全, 拦截之后会暴露session信息
```

#### 28.**js延迟加载的方式有哪些？**

```js
(1)直接将script节点放置在</body>之前, 这样js脚本就会在页面显示出来之后再加载
(2)使用script标签的defer属性, defer属性为延迟加载, 是在页面渲染完成之后再进行加载.但是有些浏览器不支持
```

```js
(3)通过监听onload事件,动态加载script节点,google推荐的代码如下:
```

```js
function downloadJSAtOnload(){
    var element = document.createElement('script');
    element.src = "defer.js";  //此处的js文件是你引入的文件路径
    document.body.appendChild(element);
}
if(window.addEventListener){
    window.addEventListener('load',downloadJSAtOnload,false);
}else if (window.attchEvent) {
    window.attchEvent('onload', downloadJSAtOnload);
}else{
    window.onload = downloadJSAtOnload;
}
```

```js
(4)通过ajax下载脚本,动态添加script节点
```

```js
var xhr = new XMLHttpRequest();
xhr.open("get","script.js",true);
xhr.onreadystatechange = function() {
    if(xhr.readyState == 4) {
        if(xhr.status >= 200 && xhr.status<300 || xhr.status==304) {
            var script = document.createElement('script');
            script.type = "text/javascript";
            script.text = xhr.responseText;
            document.body.appendChild(script);
        }
    }
}
```

#### 29.**哪些操作会造成内存泄漏？**

**内存泄漏是指向系统申请了内存后不能释放, 使得这片内存不能再被重新申请. 以下的操作会造成内存泄漏:**

 

```js
(1)当页面中元素被移除或替换时,若元素绑定的事件没有被移除, 在IE中不会做出处理,此时要先手工移除事件, 不然会造成内存泄漏.
(2)在IE中,如果循环引用的对象是DOM节点,会造成内存泄漏.
(3)闭包时构成的循环引用会造成内存泄漏.
(4)在IE中, 自动类型转箱转换会造成内存泄漏.
内存泄漏实例见: http://www.jb51.net/article/37685.htm
```

#### 30.**编写一个函数,用于统计一个字符串中出现次数最多的字符和其出现的次数？**

```js
var str = 'asdfssaaasasasasaa';
function findMaxAppearChar () {
    var arr = str.split('');
    var obj = {};
    var maxKey = ''; 
    var maxIndex = 0;
    for( var i = 0; i < arr.length; i++ ) {
        if( obj[ arr[i] ] ){
            obj[ arr[i] ] += 1;
        }else{
            obj[ arr[i] ] = 1;
        }
    }
    for( key in obj ) {
        if(obj[key] > maxIndex) {
            maxKey = key;
            maxIndex = obj[key];
        }
    }
    return ('出现最多字符是' + maxKey + ',一共出现了' + maxIndex + "次");
}
```

#### 31.**写一个获取非行内样式的函数,要求兼容IE低版本浏览器**

```js
function getStyle ( obj, attr ) {
    if( obj.currentStyle ) {
        return obj.currentStyle[ attr ]; //兼容IE低版本
    }else{
        return window.getComputedStyle( obj, null )[ attr ];
    }
}
```

#### 32.**解释jsonp的原理，以及为什么不是真正的Ajax**

```json
jsonp的原理是通过<script>标签向服务器发送请求，将前端函数名称作为参数传递到服务器，服务器接收到请求后将 JSON 数据作为该方法的参数，返回 JavaScript 文本，前端方法就可以拿到数据. 所以它并不是真正的Ajax, Ajax是异步的, 它是同步的.
```

#### 33.将数字 12345678 转化成 RMB形式 如： 12,345,678

```js
function formatNumberToRMB ( number ) {
    var str = number + '';
    var arr = str.split('').reverse(); //[8,7,6,5,4,3,2,1]
    var resultArr = [];
    for( var i = 0; i < arr.length; i++ ) {
        resultArr.push( arr[i] );
        if( (i + 1) % 3 == 0 && (i + 1) != arr.length ){
            resultArr.push(',');
        }
    }
    return resultArr.reverse().join('');
}
```

#### 34.**请写一个阻止冒泡的兼容函数**

```js
function stopPropagation ( e ) {
    e = window.event ? window.event : e;
    if( e.stopPropagation ) {
        e.stopPropagation();
    }else{
        e.cancelBubble = true;
    }
}
```

#### 35.**你如何优化自己的代码？**

```js
1.代码重用（函数封装）
2.避免使用过多的全局变量（命名空间，封闭空间，模块化mvc..）
3.拆分函数避免函数过于臃肿：单一职责原则
4.将面向过程的编程方式改为使用面向对象编程
5.适当的注释，尤其是一些复杂的业务逻辑或者是计算逻辑，都应该写出这个业务逻辑的具体过程
6.内存管理，尤其是闭包中的变量释放
```

#### 36.(惑)**列举你用过的设计模式及其场景**

在《JavaScript设计模式与开发实践》这本书中,介绍的设计模式有以下几种：

> 单例模式 | 策略模式 | 代理模式 | 迭代器模式 | 发布-订阅模式 | 命令模式 | 组合模式 | 模板方法模式 | 享元模式 | 职责链模式 | 中介者模式 | 装饰者模 | 状态模式 | 适配模式

####37. 简述event.stopImmediatePropagation和event.stopPropagation的不同

```js
两者都有阻止冒泡的作用, 但是event.stopImmediatePropagation还会阻止该元素绑定的相同类型事件的后续执行
```

#### 38.(待)**列举任一你使用的jquery和zepto插件,并说明实现原理及用途**

#### 39.**请用正则表达式将http://baidu.com/s?wd=yourname&id=21&ie=utf-8**中的id值提取出来

```js
var str = "http://baidu.com/s?wd=yourname&id=21&ie=utf-8";
var regexp = /id=(\w)*/gi;
var idValue = str.match(regexp)[0].split("=")[1];
```

#### 40.**重写setTimeout方法, 实现其回调函数传参setTimeout( function(){} , 1000, param...)(其中param..是function()回调函数的参数)**

```js
var __sto = setTimeout;
window.setTimeout = function (callback, timeout, param) {
    var args = Array.prototype.slice.call(arguments, 2);
    var _cb = function () {
        callback.apply(null, args);
    }
    __sto(_cb, timeout);
}
```

#### 41.**移动端有哪些原生触摸事件?**

```js
1.touch类: touchstart, touchmove, touchend, touchcancel
2.tap类: tap, longTap, singleTap, doubleTap
3.swipe类: swipe, swipeLeft, swipeRight, swipeUp, swipeDown
```







### 四、js高级部分

#### 1.**请将一个URL的search部分参数与值转换成一个json对象？**

```js
 function getJsonFromUrlSearch ( search ) {

    var item;
    var result = {};
    
    if( search.indexOf( '&' ) < 0){
        item = search.split( '=' );
        result[ item[ 0 ] ] = item[ 1 ];
        return JSON.stringify( result );
    }

    var splitArray = search.split( '&' );
    
    for( var i = 0; i < splitArray.length; i++ ){
        item = splitArray[ i ].split( '=' );
        result[ item[ 0 ] ] = item[ 1 ];
    }

    return JSON.stringify( result );
    
}
```

#### 2.**请实现jQuery的Ajax请求函数:**

```js
var $ = {
    //把对象转成http协议要求的字符串
    param: function( obj ){

        var html = '';
        for ( var key in obj ){
            html += key + '=' + obj[ key ] + '&';
        }
        html = html.slice( 0, -1 );
        return html;

    },

    //封装ajax方法,参数是一个对象的形式
    ajax: function( option ) {

        var type = option.type || 'get',
        var url  = option.url || '',
        var data = this.param( option.data || {} );
        var success = option.success;

        //实例化对象
        var xhr = new XMLHttpRequest();
        
        //设置请求行
        if( type == 'get' ){
            url = url + '?' + data;
            data = null;
        }
        xhr.open( type, url );
        
        //设置请求头
        if( type == 'post' ){
            xhr.setRequestHeader( 'Content-Type', 'application/x-www-form-urlencoded' );
        }
        
        //设置请求正文
        xhr.send( data );
        
        //监听并处理响应
        xhr.onreadystatechange = function() {
            if( xhr.readyState == 4 && xhr.status == 200 ){
                success( xhr.responseText );
            }
        }

    }   
    
}  
```

#### 3.(待)**请简要描述web前端性能需要考虑哪方面，你的优化思路是什么？**

#### 4.**Promise对象有哪些状态?**

```js
1.pending:初始状态, 不是成功或失败状态
2.fulfilled (也叫resolved): 意味着操作成功完成
3.rejected: 意味着操作失败

Promise对象只能从pengding状态变成fulfilled状态, 或者pending状态变成rejected状态. 不会有其他状态之间的转变.
```

#### 5.**babel和browserify的作用分别是什么?**

```js
babel是一个编译器, 可以把ES6, ES7或者React的JSX语法编译成为ES5的语法, 实现浏览器的兼容.

browserify 能够让浏览器兼容CommonJS规范的require()方法,以此让你的代码中使用require()实现模块依赖的代码能够正常执行.
```

#### 6.请写一个函数,用来实现对象的深拷贝?

```js
function deepClone( obj ){
    return JSON.parse( JSON.stringify( obj ) );
}
```

#### 7.在Javascript中什么是伪数组？如何将伪数组转化为标准数组？

```js
伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。
典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。
```

####8.《正则》写出正确的正则表达式匹配固话号，区号3-4位，第一位为0，中横线，7-8位数字，中横线，3-4位分机号格式的固话号

```js
/^[0]\d{2,3}\-\d{7,8}\-\d{3,4}$/
```

####9.写出代码对下列数组去重并从大到小排列{5,2,3,6,8,6,5,4,7,1,9}

```js
function fn(arr){
    for (var i = 0; i < arr.length-1; i++) {
        for (var j = 0; j < arr.length-1-i; j++) {
            if(arr[j]<arr[j+1]){
                var temp = arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }

        }

    }
    for (var i = 0; i < arr.length; i++) {
        var c=arr[i];
        for (var s = i+1; s < arr.length; s++) {
            if(arr[s]==c){
                //debugger;
                arr.splice(s,1);
                s--;
            }

        }
    }

    return arr;
}
console.log(fn([5,2,3,6,8,6,5,4,7,1,9]).toString());
```

#### 10.**请分别封装添加事件和移除事件的函数，用以解决兼容性问题？**

```js
function addEvent(elem, eventName, handler) {
　　if (elem.attachEvent) {
　　　　elem.attachEvent("on" + eventName,function(){
　　　　　　handler.call(elem)}); 　 //此处使用回调函数call()，让this指向elem　　
  } else if (elem.addEventListener) {
　　    elem.addEventListener(eventName, handler, false);　　
  }
}
function removeEvent(elem, eventName, handler) {
  if (elem.detachEvent) {
  　　elem.detachEvent("on" + eventName,function(){
  　　　   handler.call(elem)}); 　　　　//此处使用回调函数call()，让this指向elem　　
  } else if (elem.removeEventListener) {
  　　elem.removeEventListener(eventName, handler, false);　　
  }
}
//IE提供了attachEvent和detachEvent两个接口，而Firefox提供的是addEventListener和removeEventListener。
```

#### 11.**写一个function，清除字符串前后的空格。（兼容所有浏览器）？**

```js
if (!String.prototype.trim) { 
     String.prototype.trim = function() { 
         return this.replace(/^\s+/, "").replace(/\s+$/,"");
 } 
} 
```



### 五、HTTP和Ajax面试题

#### 1.解释jsonp的原理，以及为什么不是真正的ajax？

```js
JSONP 的原理：通过<script>标签向服务器发送请求，将前端函数名称作为参数传递到服务器，服务器接收到请求后将 JSON 数据作为该方法的参数，返回 JavaScript 文本，前端方法就可以拿到数据。
ajax是异步的,jsonp是同步的,所以它并不是真正的ajax
```

#### 2.**请描述一下cookies，sessionStorage和localStorage的区别?**

```js
1.sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁. 因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储.
2.localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
3.Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。
```

#### 3.**如何解决跨域问题?**

```http
1.JSOP跨域
2.CROS跨域
3.反向代理

理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域

出于安全考虑，服务器不允许ajax跨域获取数据，但是可以跨域获取文件内容，所以基于这一点，可以动态创建script标签，使用标签的src属性访问js文件的形式获取js脚本，并且这个js脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据，为了获取这里的参数数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据，这就是解决跨域问题的主流解决方案
```

#### 4.**简述ajax 的过程**

```js
1.创建XMLHttpRequest对象,也就是创建一个异步调用对象
2.创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
3.设置响应HTTP请求状态变化的函数
4.发送HTTP请求
5.获取异步调用返回的数据
6.使用JavaScript和DOM实现局部刷新
```

#### 5.**http常见的状态码有那些？分别代表是什么意思？**

```http
200 - 请求成功
301 - 资源（网页等）被永久转移到其它URL
404 - 请求的资源（网页等）不存在
500 - 内部服务器错误
```

#### 6. 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

```http
分为以下4个步骤：

1.当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。

2.浏览器与远程 Web 服务器通过TCP三次握手协商来建立一个TCP/IP连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。

3.一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的GET请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。

4.此时，Web 服务器提供资源服务，客户端开始下载资源。
```

#### 7. jQuery中的全局Ajax事件有哪些？

```js
ajaxComplete()
ajaxError()
ajaxSend()
ajaxStart()
ajaxStop()
ajaxSuccess()
```

#### 8.**HTTP协议目前常用的有哪几个？KEEPALIVE从哪个版本开始出现的？**

```js
HTTP协议目前常用的有1.0和1.1版本, KEEPALIVE是1.1版本才开始出现的

现在1.1版本默认支持KEEPALIVE
-HTTP1.0需要在request中增加“Connection：keep-alive” header才能够支持
```

#### 9.**请列举出几个你所知道的模板引擎？**

```http
art-template(腾讯)  https://github.com/aui/art-template
BaiduTemplate(百度) http://baidufe.github.io/BaiduTemplate/
Velocity(阿里)      https://github.com/shepherdwind/velocity.js
Handlebars          http://handlebarsjs.com
```





### 六、兼容性问题面试题合集

#### 1.**Polyfill是什么?**

```js
Polyfill的准确意思为：用于实现浏览器并不支持的原生API的代码。
例如，querySelectorAll是很多现代浏览器都支持的原生Web API，但是有些古老的浏览器并不支持，那么假设有人写了库，只要用了这个库， 你就可以在古老的浏览器里面使用document.querySelectorAll，使用方法跟现代浏览器原生API无异。那么这个库就可以称为Polyfill或者Polyfiller。
那么问题就来了。jQuery是不是一个Polyfill?答案是No。因为它并不是实现一些标准的原生API，而是封装了自己API。一个Polyfill是抹平新老浏览器 标准原生API 之间的差距的一种封装，而不是实现自己的API。
已有的一些Polyfill，如 Polymer 是让旧的浏览器也能用上 HTML5 Web Component 的一个Polyfill。FlashCanvas是用Flash实现的可以让不支持Canvas API的浏览器也能用上Canvas的Polyfill。
```

这里有一堆Polyfills，有兴趣可以把玩一下：[HTML5 Cross Browser Polyfills](https://link.jianshu.com/?t=https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills)

#### 2.**Modernizr、HTML5Shiv、respond.js三者的区别？**

```
1.HTML5Shiv主要解决HTML5提出的新的元素不被IE6-8识别。

2.Respond.js 是一个快速、轻量的 polyfill，用于为 IE6-8 以及其它不支持 CSS3 Media Queries 的浏览器提供媒体查询的 min-width 和 max-width 特性，实现响应式网页设计（Responsive Web Design）。

3.Modernizr 是一个开源的JS库，最初主要用于检测浏览器的新特性支持情况，现在默认包含了html5shiv的能力。它使得设计师可以在支持HTML5和CSS3的浏览器中充分利用HTML5和CSS3的特性进行开发，同时又不会牺牲其他不支持这些新技术的浏览器的控制。

总结:
一般情况下HTML5Shiv、respond这2个搭配使用。
Modernizr 包括那2个，并且比他们更强大一些。
```

#### 3.**webSocket如何兼容低浏览器？(阿里面试题)**

```
Adobe Flash Socket 、
ActiveX HTMLFile (IE) 、
基于 multipart 编码发送 XHR 、
基于长轮询的 XHR
```

#### 4.**经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？**

```
1.png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.

2.浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。

3.IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;Firefox下,只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。

4.IE下,even对象有x,y属性,但是没有pageX,pageY属性;Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。
```

```js
//解决方案：
var page = {};
page.x = event.x ? event.x : event.pageX;
page.y = event.y ? event.y:event.pageY;
```

```
5.Chrome 中文界面下默认会将小于12px的文本强制按照12px显示,可通过加入CSS属性-webkit-text-size-adjust: none; 解决。

6.超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}
```

